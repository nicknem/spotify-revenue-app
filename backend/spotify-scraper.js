const puppeteer = require('puppeteer');
const fs = require('fs');

// Variable pour cache (comme dans ton extension)
let cachedTop5Data = null;

// Fonction pour √©crire dans un fichier de debug
function debugLog(message) {
  const timestamp = new Date().toISOString();
  const logMessage = `${timestamp} - ${message}\n`;
  console.log(`üîç SCRAPER DEBUG: ${message}`); // Logger clairement dans la console du serveur
  // En production, on √©vite d'√©crire des fichiers, on utilise juste la console
  if (process.env.NODE_ENV !== 'production') {
    try {
      fs.appendFileSync('./debug-scraper.log', logMessage);
    } catch (err) {
      // Ignore les erreurs de fichier en production
    }
  }
}

// Fonction pour analyser le top 5 des titres populaires (version am√©lior√©e)
async function analyzeTop5Tracks(page) {
  debugLog('üîç Analyse des titres populaires avec clic sur "Afficher plus"...');
  
  // √âTAPE 1: Compter les titres AVANT le clic
  const trackCountBefore = await page.evaluate(() => {
    const tracks = document.querySelectorAll('[data-testid="tracklist-row"]');
    return tracks.length;
  });
  debugLog(`üìä AVANT clic: ${trackCountBefore} titres trouv√©s`);

  // √âTAPE 2: Essayer plusieurs m√©thodes de clic jusqu'√† ce que le HTML change
  try {
    debugLog('üîç Recherche du bouton "Afficher plus"...');
    
    // M√©thodes d'activation du bouton √† essayer (ordre optimis√©)
    const clickMethods = [
      {
        name: 'Clic JavaScript',
        action: async () => {
          await page.evaluate(() => {
            const button = document.querySelector('#main-view > div > div.main-view-container__scroll-node.ZjfaJlGQZ42nCWjD3FDm > div:nth-child(1) > div > main > section > div > div.EmeHQXR87mUskYK6xEde > div.contentSpacing > div:nth-child(1) > div > div.fnphAtjtCDYY99lYBfLK.PHHrto0Qhh4dJcnnPhwu > button');
            if (button) button.click();
          });
        }
      },
      {
        name: 'Recherche par texte (fallback)',
        action: async () => {
          const buttons = await page.$$('button');
          for (let button of buttons) {
            const text = await page.evaluate(el => el.textContent, button);
            if (text && text.includes('Afficher plus')) {
              await button.evaluate(btn => btn.click());
              break;
            }
          }
        }
      }
    ];

    // V√©rifier si le bouton existe et le rendre visible
    const showMoreButton = await page.$('#main-view > div > div.main-view-container__scroll-node.ZjfaJlGQZ42nCWjD3FDm > div:nth-child(1) > div > main > section > div > div.EmeHQXR87mUskYK6xEde > div.contentSpacing > div:nth-child(1) > div > div.fnphAtjtCDYY99lYBfLK.PHHrto0Qhh4dJcnnPhwu > button');
    
    if (showMoreButton) {
      const isVisible = await showMoreButton.isIntersectingViewport();
      const buttonText = await page.evaluate(el => el.textContent, showMoreButton);
      debugLog(`‚úÖ Bouton trouv√© - Visible: ${isVisible}, Texte: "${buttonText}"`);
      
      if (!isVisible) {
        debugLog('üîÑ Scroll vers le bouton...');
        await showMoreButton.scrollIntoView();
        await new Promise(resolve => setTimeout(resolve, 500)); // R√©duit de 1s √† 500ms
      }
    }

    // Capturer l'√©tat HTML initial
    let initialState = await page.evaluate(() => {
      const container = document.querySelector('#main-view > div > div.main-view-container__scroll-node.ZjfaJlGQZ42nCWjD3FDm > div:nth-child(1) > div > main > section > div > div.EmeHQXR87mUskYK6xEde > div.contentSpacing > div:nth-child(1) > div > div.fnphAtjtCDYY99lYBfLK.PHHrto0Qhh4dJcnnPhwu');
      return {
        html: container ? container.innerHTML.length : 0,
        tracks: document.querySelectorAll('[data-testid="tracklist-row"]').length
      };
    });
    
    debugLog(`üîç √âtat initial - HTML: ${initialState.html} chars, Tracks: ${initialState.tracks}`);

    // Essayer chaque m√©thode jusqu'√† ce que le HTML change
    let contentLoaded = false;
    
    for (let i = 0; i < clickMethods.length && !contentLoaded; i++) {
      const method = clickMethods[i];
      debugLog(`üñ±Ô∏è Tentative ${i + 1}: ${method.name}`);
      
      try {
        await method.action();
        debugLog(`‚úÖ ${method.name} ex√©cut√©`);
        
        // Surveiller les changements HTML pendant 1 seconde max (React est tr√®s rapide)
        const startTime = Date.now();
        const timeout = 1000; // 1 seconde suffit
        
        while (!contentLoaded && (Date.now() - startTime) < timeout) {
          await new Promise(resolve => setTimeout(resolve, 50)); // V√©rifier toutes les 50ms (plus fr√©quent)
          
          const currentState = await page.evaluate(() => {
            const container = document.querySelector('#main-view > div > div.main-view-container__scroll-node.ZjfaJlGQZ42nCWjD3FDm > div:nth-child(1) > div > main > section > div > div.EmeHQXR87mUskYK6xEde > div.contentSpacing > div:nth-child(1) > div > div.fnphAtjtCDYY99lYBfLK.PHHrto0Qhh4dJcnnPhwu');
            return {
              html: container ? container.innerHTML.length : 0,
              tracks: document.querySelectorAll('[data-testid="tracklist-row"]').length
            };
          });
          
          const htmlChange = currentState.html - initialState.html;
          const trackChange = currentState.tracks - initialState.tracks;
          
          if (htmlChange > 1000 || trackChange > 0) { // Changement significatif
            debugLog(`üéâ SUCC√àS! HTML: +${htmlChange} chars, Tracks: +${trackChange}`);
            debugLog(`üìä ${method.name} a fonctionn√© apr√®s ${((Date.now() - startTime)).toFixed(0)}ms`);
            contentLoaded = true;
            break;
          }
        }
        
        if (!contentLoaded) {
          debugLog(`‚ö†Ô∏è ${method.name} - Pas de changement d√©tect√© apr√®s 1s`);
        }
        
      } catch (error) {
        debugLog(`‚ùå ${method.name} √©chou√©: ${error.message}`);
      }
    }
    
    if (!contentLoaded) {
      debugLog('‚ö†Ô∏è Aucune m√©thode n\'a r√©ussi √† charger plus de contenu');
      debugLog('üîÑ Utilisation des 5 tracks de base');
    }
    
  } catch (error) {
    debugLog('‚ö†Ô∏è Erreur lors du clic sur "Afficher plus": ' + error.message);
  }

  // √âTAPE 3: Compter les titres APR√àS le clic avec data-testid
  const trackCountAfter = await page.evaluate(() => {
    const tracks = document.querySelectorAll('[data-testid="tracklist-row"]');
    return tracks.length;
  });
  debugLog(`üìä APR√àS clic: ${trackCountAfter} titres trouv√©s`);
  debugLog(`üìà Diff√©rence: +${trackCountAfter - trackCountBefore} nouveaux titres`);
  
  return await page.evaluate(() => {
    // Scanner TOUS les titres APR√àS le clic avec data-testid
    const trackRows = document.querySelectorAll('[data-testid="tracklist-row"]');
    console.log(`üéµ ${trackRows.length} lignes de titres trouv√©es APR√àS le clic`);
    
    const allStreams = [];
    
    // Analyser TOUS les titres trouv√©s
    console.log(`üéµ Analyse de tous les ${trackRows.length} titres`);
    for (let i = 0; i < trackRows.length; i++) {
      const row = trackRows[i];
      const rowText = row.textContent;
      
      console.log(`üìä Ligne ${i+1}: "${rowText.substring(0, 100)}..."`);
      
      // Chercher le div avec la classe qui contient les streams
      const streamDivs = row.querySelectorAll('div[class*="encore-text"]');
      
      for (let div of streamDivs) {
        const divText = div.textContent.trim();
        
        // Chercher un pattern de streams (nombre avec ou sans espaces, pas de : pour dur√©e)
        if (!divText.includes(':') && divText.match(/^\d{1,3}(?:\s\d{3})*$|^\d{1,3}\s\d{3}$|^\d{4,7}$/)) {
          const streamCount = parseInt(divText.replace(/\s/g, ''));
          
          if (streamCount > 100 && streamCount < 50000000) { // Limite plus basse pour petits artistes
            console.log(`üéØ Stream trouv√© ligne ${i+1}: ${streamCount.toLocaleString()} (texte: "${divText}")`);
            allStreams.push(streamCount);
            break; // Passer au titre suivant
          }
        }
      }
    }
    
    // Fallback si pas de trackRows : ancienne m√©thode
    if (trackRows.length === 0) {
      console.log('üîÑ Fallback: recherche par H2 Populaires...');
      
      // Chercher le h2 "Populaires"
      const h2Elements = document.querySelectorAll('h2');
      let popularesH2 = null;
      
      for (let h2 of h2Elements) {
        if (h2.textContent.trim() === 'Populaires') {
          popularesH2 = h2;
          console.log('‚úÖ H2 "Populaires" trouv√© !');
          break;
        }
      }
      
      if (popularesH2) {
        // Chercher la section parent qui contient les titres
        let popularSection = popularesH2.closest('section') || popularesH2.parentElement;
        
        if (popularSection) {
          console.log('‚úÖ Section Populaires trouv√©e !');
          
          // Fallback avec parsing manuel des nombres s√©par√©s par espaces
          const sectionText = popularSection.textContent;
          console.log(`üìÑ Texte section (300 chars): "${sectionText.substring(0, 300)}..."`);
          
          // Pattern sp√©cial pour nombres avec espaces comme "1 791 149"
          const spaceNumberPattern = /\b(\d{1,3}(?:\s\d{3}){1,2})\b/g;
          const matches = sectionText.match(spaceNumberPattern);
          
          console.log(`üîç Nombres avec espaces trouv√©s: ${matches ? matches.join(', ') : 'aucun'}`);
          
          if (matches) {
            for (let match of matches) {
              const streamCount = parseInt(match.replace(/\s/g, ''));
              
              if (streamCount > 10000 && streamCount < 50000000) {
                console.log(`üéµ Stream valid√© (fallback): ${streamCount.toLocaleString()}`);
                allStreams.push(streamCount);
              }
            }
          }
        }
      }
    }
    
    if (allStreams.length >= 3) {
      // Trier par ordre d√©croissant et prendre TOUS les titres trouv√©s (pas seulement 5)
      allStreams.sort((a, b) => b - a);
      const finalTracks = allStreams; // Prendre tous les titres
      
      // Pond√©ration : r√©duire le hit principal de 20% (moins agressive)
      const weightedTracks = [...finalTracks];
      if (weightedTracks.length > 0) {
        const originalTop1 = weightedTracks[0];
        weightedTracks[0] = Math.round(weightedTracks[0] * 0.8);
        console.log(`‚öñÔ∏è Pond√©ration du hit principal: ${originalTop1.toLocaleString()} ‚Üí ${weightedTracks[0].toLocaleString()}`);
      }
      
      const average = weightedTracks.reduce((sum, streams) => sum + streams, 0) / weightedTracks.length;
      
      console.log(`‚úÖ Top ${finalTracks.length} streams trouv√©s:`);
      finalTracks.forEach((streams, i) => {
        if (i === 0) {
          console.log(`   ${i+1}. ${streams.toLocaleString()} streams (pond√©r√©: ${weightedTracks[0].toLocaleString()})`);
        } else {
          console.log(`   ${i+1}. ${streams.toLocaleString()} streams`);
        }
      });
      console.log(`‚úÖ Moyenne pond√©r√©e: ${Math.round(average).toLocaleString()} streams`);
      
      return {
        tracks: finalTracks,
        average: average,
        count: finalTracks.length
      };
    }
    
    console.log(`‚ùå Pas assez de streams trouv√©s (${allStreams.length}/3 minimum)`);
    return null;
  });
}

// Fonction pour trouver le nombre d'auditeurs mensuels (adapt√©e de ton code)
async function getMonthlyListeners(page) {
  return await page.evaluate(() => {
    console.log('üîç Recherche des auditeurs mensuels...');
    
    // Strat√©gie 1: Chercher dans les √©l√©ments visibles seulement
    const visibleElements = document.querySelectorAll('span, div, p, h1, h2, h3');
    console.log(`üëÄ Nombre d'√©l√©ments visibles √† analyser: ${visibleElements.length}`);
    
    // Patterns multilingues √† rechercher
    const patterns = [
      'auditeurs mensuels',
      'monthly listeners', 
      'mensuel',
      'listeners',
      '√©coutes mensuelles'
    ];
    
    for (let element of visibleElements) {
      const text = element.textContent;
      
      // V√©rifier chaque pattern de langue
      for (let pattern of patterns) {
        if (text && text.toLowerCase().includes(pattern) && text.length < 100) {
          console.log(`‚úÖ Trouv√© texte avec "${pattern}": "${text}"`);
          console.log(`üìù Longueur: ${text.length} caract√®res`);
          
          // Pattern pour extraire les nombres (multi-format)
          const numberMatch = text.match(/(\d[\d\s,\.]*\d|\d+)\s*(auditeurs mensuels|monthly listeners|mensuel|listeners)/i);
          if (numberMatch && numberMatch[1]) {
            const number = parseInt(numberMatch[1].replace(/[\s,\.]/g, ''));
            console.log(`üéØ Nombre extrait: ${number}`);
            
            // V√©rification de sanit√©: entre 1 et 100 millions
            if (number > 0 && number < 100000000) {
              return number;
            }
          }
        }
      }
    }
    
    // Strat√©gie 2: Chercher n'importe quel gros nombre qui pourrait √™tre les auditeurs
    console.log('üîÑ Strat√©gie 2: recherche de gros nombres dans le contenu');
    
    const allNumbers = [];
    for (let element of visibleElements) {
      const text = element.textContent;
      
      if (text && text.length < 100) {
        // Chercher des nombres de format "X,XXX,XXX" ou "X XXX XXX"
        const bigNumbers = text.match(/\d[\d\s,\.]{4,}/g);
        if (bigNumbers) {
          bigNumbers.forEach(numStr => {
            const cleanNum = parseInt(numStr.replace(/[\s,\.]/g, ''));
            if (cleanNum > 100000 && cleanNum < 100000000) { // Entre 100K et 100M
              allNumbers.push({number: cleanNum, context: text});
              console.log(`üî¢ Nombre candidat: ${cleanNum.toLocaleString()} dans "${text}"`);
            }
          });
        }
      }
    }
    
    // Si on a trouv√© des nombres, prendre le plus gros (probablement les auditeurs mensuels)
    if (allNumbers.length > 0) {
      const biggest = allNumbers.sort((a, b) => b.number - a.number)[0];
      console.log(`üéØ Plus gros nombre trouv√©: ${biggest.number.toLocaleString()}`);
      return biggest.number;
    }
    
    // Strat√©gie 3: Recherche sp√©cifique pour "auditeurs" en fran√ßais
    console.log('üîÑ Strat√©gie 3: recherche sp√©cifique texte fran√ßais');
    
    for (let element of visibleElements) {
      const text = element.textContent;
      
      if (text && text.length < 50 && text.includes('auditeurs')) {
        console.log(`üîç Texte candidat: "${text}"`);
        
        // Chercher pattern "17 525 auditeurs mensuels" ou similaire
        const match = text.match(/(\d{1,3}(?:\s\d{3})*)\s*auditeurs/);
        if (match && match[1]) {
          const number = parseInt(match[1].replace(/\s/g, ''));
          console.log(`üéØ Nombre trouv√© strat√©gie 2: ${number}`);
          if (number > 0 && number < 100000000) {
            return number;
          }
        }
      }
    }
    
    console.log('‚ùå Aucun auditeur mensuel trouv√©');
    return null;
  });
}

// Fonction pour calculer streams par auditeur intelligemment (adapt√©e de ton code)
function calculateStreamsPerListener(monthlyListeners) {
  console.log(`üéØ Calcul intelligent pour ${monthlyListeners} auditeurs`);
  
  // √âtape 1: Utiliser les donn√©es en cache si disponibles
  if (cachedTop5Data) {
    console.log('üíæ Utilisation des donn√©es top 5 en cache');
    // Calcul bas√© sur les donn√©es r√©elles
    const hitRatio = cachedTop5Data.average / monthlyListeners;
    console.log(`üìä Hit ratio: ${hitRatio.toFixed(2)}`);
    
    // Algorithme adaptatif hybride
    const baseCoeff = 0.6; // Base augment√©e
    const hitRatioFactor = Math.min(1.5, 0.7 + hitRatio / 15); // Formule moins p√©nalisante
    
    // Multiplicateur par taille d'audience
    let sizeMultiplier, category;
    if (monthlyListeners < 50000) {
      sizeMultiplier = 1.0; // Fans plus engag√©s
      category = 'Artiste √©mergent';
    } else if (monthlyListeners < 500000) {
      sizeMultiplier = 0.85;
      category = 'Artiste en croissance';
    } else if (monthlyListeners < 2000000) {
      sizeMultiplier = 0.7;
      category = 'Artiste √©tabli';
    } else {
      sizeMultiplier = 0.6;
      category = 'Artiste mainstream';
    }
    
    const adaptiveCoeff = baseCoeff * hitRatioFactor * sizeMultiplier;
    const calculatedRatio = hitRatio * adaptiveCoeff;
    const finalRatio = Math.max(0.5, Math.min(50, calculatedRatio));
    
    console.log(`üìà Cat√©gorie: ${category}`);
    console.log(`üìà Base coeff: ${baseCoeff}, Hit factor: ${hitRatioFactor.toFixed(2)}, Size mult: ${sizeMultiplier}`);
    console.log(`üìà Coefficient adaptatif: ${adaptiveCoeff.toFixed(3)}`);
    console.log(`‚úÖ Ratio intelligent: ${finalRatio.toFixed(2)} streams/auditeur`);
    
    return finalRatio;
  } else {
    // Fallback sur la courbe classique
    console.log('üîÑ Fallback sur la courbe classique (pas de donn√©es top 5)');
    return calculateStreamsPerListenerFallback(monthlyListeners);
  }
}

// Fonction de fallback (adapt√©e de ton code)
function calculateStreamsPerListenerFallback(monthlyListeners) {
  let baseRatio;
  let variationRange;
  
  if (monthlyListeners < 50000) {
    baseRatio = 4;
    variationRange = 1;
    console.log('üìä Fallback - Cat√©gorie: Artiste √©mergent');
  } else if (monthlyListeners < 500000) {
    baseRatio = 6.5;
    variationRange = 1.5;
    console.log('üìä Fallback - Cat√©gorie: Artiste en croissance');
  } else if (monthlyListeners < 2000000) {
    baseRatio = 5;
    variationRange = 1;
    console.log('üìä Fallback - Cat√©gorie: Artiste √©tabli');
  } else {
    baseRatio = 3;
    variationRange = 1;
    console.log('üìä Fallback - Cat√©gorie: Artiste mainstream');
  }
  
  const randomFactor = (Math.random() - 0.5) * variationRange;
  const finalRatio = Math.max(1, baseRatio + randomFactor);
  
  console.log(`‚úÖ Ratio fallback: ${finalRatio.toFixed(1)} streams/auditeur`);
  return finalRatio;
}

// Fonction pour calculer les revenus estim√©s (adapt√©e de ton code)
function calculateRevenue(monthlyListeners) {
  // Utilise la courbe intelligente au lieu d'un ratio fixe
  const streamsPerListener = calculateStreamsPerListener(monthlyListeners);
  const revenuePerStream = 0.004; // $0.004 par stream
  const usdToEur = 0.92; // Taux de change approximatif USD -> EUR
  
  const monthlyStreams = monthlyListeners * streamsPerListener;
  const monthlyRevenueUSD = monthlyStreams * revenuePerStream;
  const monthlyRevenueEUR = monthlyRevenueUSD * usdToEur;
  
  return {
    streams: monthlyStreams,
    revenue: monthlyRevenueEUR,
    ratio: streamsPerListener
  };
}

// Fonction pour formater les nombres (adapt√©e de ton code)
function formatNumber(num) {
  if (num >= 1000000) {
    return (num / 1000000).toFixed(1).replace('.', ',') + 'M';
  } else if (num >= 1000) {
    return (num / 1000).toFixed(0) + 'K';
  } else {
    return num.toString();
  }
}

// Fonction pour formater les revenus (adapt√©e de ton code)
function formatRevenue(revenue) {
  return Math.round(revenue).toLocaleString('fr-FR');
}

// Fonction principale pour scraper un artiste
async function scrapeArtistRevenue(artistUrl) {
  console.log(`üöÄ Scraping artist: ${artistUrl}`);
  
  // IMPORTANT: Vider le cache pour forcer une nouvelle analyse
  cachedTop5Data = null;
  console.log('üóëÔ∏è Cache vid√© - nouvelle analyse forc√©e');
  
  const browser = await puppeteer.launch({ 
    headless: true,
    args: [
      '--no-sandbox', 
      '--disable-setuid-sandbox',
      '--disable-dev-shm-usage', // Performance
      '--disable-accelerated-2d-canvas', // Performance
      '--disable-gpu', // Performance
      '--disable-background-timer-throttling', // Performance
      '--disable-backgrounding-occluded-windows',
      '--disable-renderer-backgrounding',
      '--single-process' // Plus rapide mais plus de m√©moire
    ]
  });
  
  try {
    const page = await browser.newPage();
    
    // Capturer les logs de la page pour d√©bugger
    page.on('console', msg => {
      console.log('PAGE LOG:', msg.text());
    });
    
    // Simuler un vrai navigateur
    await page.setUserAgent('Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
    
    console.log('üìç Navigation vers la page artiste...');
    await page.goto(artistUrl, { waitUntil: 'domcontentloaded', timeout: 15000 }); // Plus rapide que networkidle0
    
    // Attente r√©duite - le DOM est d√©j√† charg√©
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    console.log('üîç Recherche des auditeurs mensuels...');
    const monthlyListeners = await getMonthlyListeners(page);
    
    if (!monthlyListeners) {
      throw new Error('Impossible de trouver le nombre d\'auditeurs mensuels');
    }
    
    console.log('üîç Analyse du top 5...');
    cachedTop5Data = await analyzeTop5Tracks(page);
    
    console.log('üí∞ Calcul des revenus...');
    const estimates = calculateRevenue(monthlyListeners);
    
    const result = {
      monthlyListeners,
      estimates: {
        streams: estimates.streams,
        revenue: estimates.revenue,
        ratio: estimates.ratio
      },
      top5Data: cachedTop5Data,
      formatted: {
        listeners: formatNumber(monthlyListeners),
        streams: formatNumber(estimates.streams),
        revenue: formatRevenue(estimates.revenue)
      }
    };
    
    console.log('‚úÖ Scraping termin√© avec succ√®s !');
    return result;
    
  } catch (error) {
    console.error('‚ùå Erreur lors du scraping:', error);
    throw error;
  } finally {
    await browser.close();
  }
}

module.exports = {
  scrapeArtistRevenue,
  calculateRevenue,
  formatNumber,
  formatRevenue
};